#!/bin/sh
#
# Copyright (C) 2025-26 https://github.com/ArKT-7/NoPcWinstall
#
# Made For installing Windows on WOA supported devices without using any other device or recovery.

# Define URLs and target paths for binaries
BASE_URL="https://raw.githubusercontent.com/arkt-7/NoPcWinstall/main/bin"
URL_BUSYBOX="$BASE_URL/busybox"
URL_TOOLSBIN="$BASE_URL/bin.zip"
URL_INSBAT="$BASE_URL/install.bat"

BIN_DIR="/tmp/arkt/winstall"
WORK_DIR="/sdcard/ArKT-Winstall"
BACKUP_DIR="/sdcard/ArKT-Winstall-Backups"

umount -lf /dev/block/platform/soc/1d84000.ufshc/by-name/{esp,win} 2>/dev/null
rm -rf "$BIN_DIR"
mkdir -p "$BIN_DIR"
rm -rf "$WORK_DIR"
mkdir -p "$WORK_DIR"
rm -rf "$BACKUP_DIR"
mkdir -p "$BACKUP_DIR"
cd "$BIN_DIR"

for i in /sys/devices/system/cpu/cpu[0-9]*; do
    echo performance > "$i/cpufreq/scaling_governor" 2>/dev/null
done

log() {
    echo ""
    echo "[$(date +"%H:%M:%S")] $1"
}

# Function to download and set permissions
download_and_set_permissions() {
    local url=$1 dest_file=$2
    log "[INFO] Downloading $(basename "$dest_file")..."
    curl -L -# -o "$dest_file" "$url" || { log "[ERROR] Failed to download $(basename "$dest_file")"; exit 1; }
    chmod 777 "$dest_file"
    echo "[SUCCESS] $(basename "$dest_file") ready."
}

# Function to download files without setting permissions
download_file() {
    local url=$1 dest_file=$2
    curl -L -# -o "$dest_file" "$url" || { log "[ERROR] Failed to download $(basename "$dest_file")"; }
    echo "[SUCCESS] $(basename "$dest_file") downloaded."
}

# Functions to convert bytes
bytes_to_gb() {
    "$BIN_DIR/busybox" awk -v bytes="$1" 'BEGIN { printf "%.2f", bytes / (1000 * 1000 * 1000) }'
}

bytes_to_mb() {
    "$BIN_DIR/busybox" awk -v bytes="$1" 'BEGIN { printf "%.2f", bytes / (1000 * 1000) }'
}

copy_folder_with_progress() {
    local src="$1"
    local dst="$2"
    local total_size
    total_size=$("$BIN_DIR/busybox" du -sb "$src" | "$BIN_DIR/busybox" awk '{print $1}')
    mkdir -p "$dst"
    (cd "$src" && "$BIN_DIR/busybox" tar -cf - .) \
        | ionice -c 1 -n 0 nice -n -20 "$BIN_DIR/pv" -B 16M -s "$total_size" \
        | (cd "$dst" && "$BIN_DIR/busybox" tar -xf -)
}

copy_file_with_progress() {
    local src="$1"
    local dst="$2"
    local size
    size=$("$BIN_DIR/busybox" stat -c %s "$src")
    mkdir -p "$(dirname "$dst")"
    ionice -c 1 -n 0 nice -n -20 \
      "$BIN_DIR/pv" -B 16M -s "$size" "$src" \
      | "$BIN_DIR/busybox" dd of="$dst" bs=4M status=none
    echo ""
}

# Define partition paths and other stuffs
disk="/dev/block/sda"
part_win="/dev/block/platform/soc/1d84000.ufshc/by-name/win"
part_esp="/dev/block/platform/soc/1d84000.ufshc/by-name/esp"
part_userdata="/dev/block/platform/soc/1d84000.ufshc/by-name/userdata"
win="/dev/block/platform/soc/1d84000.ufshc/sda32"
esp="/dev/block/platform/soc/1d84000.ufshc/sda31"
userdata="/dev/block/sda33"
metadata="/dev/block/sda19"
RESERVED_START=11222
RESERVED_END=7000

repartition_windows() {
    echo -n "\nDo you want to proceed with partitioning? (y/n): "
    read -r first_confirmation
    first_confirmation=$(echo "$first_confirmation" | tr '[:upper:]' '[:lower:]')
    if [[ "$first_confirmation" != "y" && "$first_confirmation" != "yes" ]]; then
        log "[INFO] Repartitioning cancelled.\n"
        exit 0
    fi
    echo -n "\n[Warning] All data will be erased. Do you want to continue? (y/n): "
    read -r second_confirmation
    second_confirmation=$(echo "$second_confirmation" | tr '[:upper:]' '[:lower:]')
    if [[ "$second_confirmation" != "y" && "$second_confirmation" != "yes" ]]; then
        log "[INFO] Repartitioning cancelled.\n"
        exit 0
    fi
    blocksize=$("$BIN_DIR/busybox" blockdev --getsize64 /dev/block/sda)
    max=$(bytes_to_mb "$blocksize" | cut -d'.' -f1)
    usable_mb=$((max - RESERVED_START - RESERVED_END))
    winmax=$((usable_mb / 1000))
    log "[INFO] Maximum space available for Windows: $winmax GB\n"
    while true; do
        echo -n "Enter desired Windows size in GB (e.g., 70), or press Enter for 50% split: "
        read -r input
        size=$(echo "$input" | tr -d '[:space:]' | tr '[:upper:]' '[:lower:]' | sed 's/gb$//;s/[^0-9.]//g')
        if [ -z "$input" ]; then
            winend=$(((max + RESERVED_START) / 2))
        else
            case "$size" in
                ''|*[!0-9.]*)
                    echo "[Warning] Invalid input. Please enter a number like 70.\n"
                    continue
                    ;;
            esac
            size_int=$(echo "$size" | cut -d'.' -f1)
            if [ "$size_int" -lt 25 ] || [ "$size_int" -gt "$winmax" ]; then
                echo "[Warning] Invalid size. Please choose between 25 GB and $winmax GB.\n"
                continue 
            fi
            winend=$("$BIN_DIR/busybox" awk -v sz="$size" -v start="$RESERVED_START" '
                BEGIN {
                    mb = int(sz * 1000 + 0.5)
                    aligned = int((mb + 1023) / 1024) * 1024
                    print aligned + start
                }')
        fi
        windows_gb=$("$BIN_DIR/busybox" awk -v end="$winend" -v start="$RESERVED_START" 'BEGIN { printf "%.2f", (end - start)/1000 }')
        userdata_gb=$("$BIN_DIR/busybox" awk -v end="$winend" -v total="$max" 'BEGIN { printf "%.2f", (total - end)/1000 }')
        echo "\nWindows Partition: $windows_gb GB"
        echo "Android Partition: $userdata_gb GB\n"
        while true; do
            echo -n "Does this look good? (y/n): "
            read -r yn
            case "$yn" in
                [Yy]* ) confirm_ok=1; break ;;
                [Nn]* ) echo "OK, Please enter a new Windows size.\n"; confirm_ok=0; break ;;
                * ) echo "Please enter y or n."; echo "" ;;
            esac
        done
        [ "$confirm_ok" -eq 1 ] && break
    done
    log "[INFO] Proceeding with Windows partitioning...\n"
    for dev in a b c d e f; do
        "$BIN_DIR/gdisk" "/dev/block/sd$dev" <<< $'x\nj\n\nk\n\nw\nY\n'
        echo " "
    done
    for i in sdcard data; do
        umount -lf /$i 2>/dev/null
    done
    "$BIN_DIR/dmsetup" remove -f userdata 2>/dev/null
    for i in esp win linux firmware mnt userdata metadata misc vendor; do
        umount -lf /dev/block/platform/soc/1d84000.ufshc/by-name/$i 2>/dev/null
    done
    "$BIN_DIR/sgdisk" --clear --load-backup="$BIN_DIR/stock_gpt_nabu" "$disk"
    "$BIN_DIR/sgdisk" --resize-table 64 "$disk"
    "$BIN_DIR/parted" -s "$disk" \
        rm 31 \
        mkpart esp fat32 10872MB 11222MB \
        mkpart win ntfs 11222MB "${winend}MB" \
        mkpart userdata ext4 "${winend}MB" 100% \
        set 31 esp on
    sync
    "$BIN_DIR/make_f2fs" -f -g android "$userdata"
    "$BIN_DIR/mke2fs" -t ext4 -F "$metadata"
    "$BIN_DIR/mkfs.fat" -F32 -s1 "$esp" -n ESPNABU
    "$BIN_DIR/mkfs.ntfs" -f "$win" -L WINNABU
    sync
    "$BIN_DIR/parted" "$disk" p free
    log "[INFO] Repartitioning done!"
    log "[INFO] Waiting for 5 seconds before rebooting..."
    sleep 5
    reboot
}

clear
echo "\n\nThis script is Written and Made By °⊥⋊ɹ∀°, Telegram - '@ArKT_7', Github - 'ArKT-7'\n"
echo "Based on Kumar_Jy's Wininstaller, Telegram - '@Kumar_Jy', Github - 'Kumar-Jy'\n"

# Check the device codename using getprop
DEVICE_CODENAME=$(getprop ro.product.device)
if [ "$DEVICE_CODENAME" != "nabu" ]; then
    echo "\nThis device is not supported yet. Please contact the developer on Telegram @ArKT_7\n"
    echo "your Device - $DEVICE_CODENAME\n"
    exit 1
fi

# Download and set permissions for binaries
download_and_set_permissions "$URL_BUSYBOX" "$BIN_DIR/busybox"
download_and_set_permissions "$URL_TOOLSBIN" "$BIN_DIR/bin.zip"
download_and_set_permissions "$URL_INSBAT" "$BIN_DIR/install.bat"
"$BIN_DIR/busybox" unzip -o -q "$BIN_DIR/bin.zip" -d "$BIN_DIR"
chmod -R 777 "$BIN_DIR"
log "[INFO] All binaries have been downloaded and permissions set."

echo "\n\nThis script is Written and Made By °⊥⋊ɹ∀°, Telegram - '@ArKT_7', Github - 'ArKT-7'\n"
echo "Based on Kumar_Jy's Wininstaller, Telegram - '@Kumar_Jy', Github - 'Kumar-Jy'\n"

log "[INFO] let's proceed further!\n"

# Get sizes in bytes
size_win=$("$BIN_DIR/busybox" blockdev --getsize64 "$part_win" 2>/dev/null)
size_esp=$("$BIN_DIR/busybox" blockdev --getsize64 "$part_esp" 2>/dev/null)
size_userdata=$("$BIN_DIR/busybox" blockdev --getsize64 "$part_userdata" 2>/dev/null)

# Convert sizes
size_win_gb=$(bytes_to_gb $size_win)
size_esp_mb=$(bytes_to_mb $size_esp)
size_userdata_gb=$(bytes_to_gb $size_userdata)

# Check if either Windows or ESP partition is missing
if [ ! -e "$part_win" ] || [ ! -e "$part_esp" ]; then
    log "[Warning] Windows and/or ESP partitions are missing."
    echo "\nCurrent Size of Windows Partition: NOTHING LOL"
    echo "Current Size of ESP Partition: NOTHING LOL\n"
    echo "Current Size of Android Partition: $size_userdata_gb GB"
    log "[INFO] need to do partitioning for windows"
    repartition_windows
fi

# Print sizes
echo "\nSize of Windows Partition: $size_win_gb GB"
echo "Size of ESP Partition: $size_esp_mb MB"
echo "Size of Android partition: $size_userdata_gb GB\n"

# Check partition sizes
if [ $(echo "$size_esp_mb < 349" | bc) -eq 1 ]; then
    echo "ESP partition is less than 350 MB."
    repartition_windows
fi

if [ $(echo "$size_win_gb < 25" | bc) -eq 1 ]; then
    echo "Windows partition is less than 25 GB."
    repartition_windows
fi

# Continue with other operations if checks pass
log "[INFO] Partition sizes are sufficient."

log "[INFO] ESP and Windows partitions already exist.\n\n"
echo -n  "Do you want to re-partition - r or continue with the existing partitions - c? (r/c): "
read -r first_confirmation
if [[ "$first_confirmation" == "r" || "$first_confirmation" == "repart" ]]; then
    log "[INFO] OK, repartitioning will be done now."
    repartition_windows
else
    log "[INFO] Skipping repartitioning of Windows."
    log "[NOTE] The Windows partition will be formatted, and the installation will proceed in the same partition.\n"
fi

log "[INFO] Proceeding with the rest of the Things...\n"

# Print sizes
echo "\nSize of Windows Partition: $size_win_gb GB"
echo "Size of ESP Partition: $size_esp_mb MB"
echo "Size of Android partition: $size_userdata_gb GB\n"

log "[INFO] Searching for WinInstaller ZIP files...\n"

count=1
files=()
required_files=("pe.img" "install.bat" "sta.exe" "sha256sum" "uefi.img")
temp_file="$BIN_DIR/zip_list.txt"

"$BIN_DIR/busybox" find "/sdcard/" \
    -type d \( -name "Android" -o -name ".*" \) -prune -o \
    -type f -name "*.zip" -print > "$temp_file"

while IFS= read -r file; do
    if [ -f "$file" ]; then
        # Check if all required files exist in the zip
        all_found=true
        for req in "${required_files[@]}"; do
            if ! "$BIN_DIR/busybox" unzip -l "$file" | "$BIN_DIR/busybox" grep -q "$req"; then
                all_found=false
                break
            fi
        done
        if [ "$all_found" = true ]; then
            RELATIVE_PATH=${file#/sdcard/}
            echo "$count. $RELATIVE_PATH"
            files[$count]="$file"
            count=$((count + 1))
        fi
    fi
done < "$temp_file"
rm -f "$temp_file"
if [ "$count" -eq 1 ]; then
    log "[ERROR] No valid Wininstaller ZIP files found (must download it first!).\n"
    exit 1
fi

# Automatically select the ZIP file if only one is available
if [ "$count" -eq 2 ]; then
    SELECTED_ZIP_FILE="${files[1]}"
    echo ""
    echo "Only one valid ZIP file found: $(basename "$SELECTED_ZIP_FILE")"
    echo "Automatically selecting this file!"
else
    echo -n "\nEnter the serial number of the ZIP file to select: "
    read -r selection
    if [ -z "${files[$selection]}" ]; then
        log "[ERROR] Invalid selection, exiting xD, try again!\n"
        exit 1
    fi
    SELECTED_ZIP_FILE="${files[$selection]}"
fi

log "[INFO] Extracting Wininstaller zip, please wait..."

spinner='|/-\\'
spin_i=0
start_time=$(date +%s)
total_files=$("$BIN_DIR/busybox" unzip -l "$SELECTED_ZIP_FILE" | "$BIN_DIR/busybox" grep -vE 'Archive|----' | "$BIN_DIR/busybox" wc -l | tr -d ' ')
"$BIN_DIR/busybox" unzip -o -q "$SELECTED_ZIP_FILE" -d "$WORK_DIR" &
unzip_pid=$!
while kill -0 "$unzip_pid" 2>/dev/null; do
    now=$(date +%s)
    elapsed=$((now - start_time))
    hours=$((elapsed / 3600))
    minutes=$(((elapsed % 3600) / 60))
    seconds=$((elapsed % 60))
    elapsed_formatted=$(printf "%02d:%02d:%02d" $hours $minutes $seconds)
    extracted_files=$("$BIN_DIR/busybox" find "$WORK_DIR" -type f | wc -l)
    if [ "$total_files" -gt 0 ]; then
        percent=$((extracted_files * 100 / total_files))
        [ "$percent" -gt 100 ] && percent=100
    else
        percent=0
    fi
    spin_char=$(printf "%s" "$spinner" | cut -c $(( (spin_i % 4) + 1 )) )
    spin_i=$((spin_i + 1))
    printf "\r[%s] Extracting... %d%% Elapsed: %s" "$spin_char" "$percent" "$elapsed_formatted"
    sleep 0.3
done
wait "$unzip_pid"
printf "\r\033[K"  # Clear line after finish

for file in "${required_files[@]}"; do
    if ! "$BIN_DIR/busybox" find "$WORK_DIR" -type f -name "$file" | grep -q .; then
        log "[ERROR] Extraction failed — missing: $file\n"
        exit 1
    fi
done
rm -f "$WORK_DIR/installer/install.bat"
"$BIN_DIR/busybox" mv "$WORK_DIR/installer/pe.img" "$WORK_DIR" 
"$BIN_DIR/busybox" mv "$WORK_DIR/installer/uefi.img" "$WORK_DIR" 
"$BIN_DIR/busybox" cp -r "$BIN_DIR/install.bat" "$WORK_DIR/installer/"
log "[INFO] All required files extracted successfully.\n"

log "[INFO] Searching for Windows .esd/.wim files...\n"

count=1
files=()
temp_file="$BIN_DIR/win_list.txt"

"$BIN_DIR/busybox" find "/sdcard/" \
    -type d \( -name "Android" -o -name ".*" \) -prune -o \
    -type f \( -iname "*.esd" -o -iname "*.wim" \) -print > "$temp_file"

while IFS= read -r file; do
    if [ -f "$file" ]; then
        RELATIVE_PATH=${file#/sdcard/}
        echo "$count. $RELATIVE_PATH"
        files[$count]="$file"
        count=$((count + 1))
    fi
done < "$temp_file"
rm -f "$temp_file"

if [ "$count" -eq 1 ]; then
    log "[ERROR] No .esd or .wim files found. Please copy it to internal storage first!\n"
    exit 1
fi

# Automatically select the file if only one is found
if [ "$count" -eq 2 ]; then
    SELECTED_WIN_FILE="${files[1]}"
    echo "\nOnly one valid .esd/.wim file found: $(basename "$SELECTED_WIN_FILE")"
    echo "Automatically selecting this file!"
else
    echo -n "\nEnter the serial number of the Windows .esd/.wim file to select: "
    read -r selection
    if [ -z "${files[$selection]}" ]; then
        log "[ERROR] Invalid selection, exiting xD, try again!\n"
        exit 1
    fi
    SELECTED_WIN_FILE="${files[$selection]}"
fi
echo "\n\nSelected Windows file path: $SELECTED_WIN_FILE"

# Check the file extension and set the appropriate destination filename
extension="${SELECTED_WIN_FILE##*.}"
if [ "$extension" = "esd" ]; then
    DEST_FILE="install.esd"
elif [ "$extension" = "wim" ]; then
    DEST_FILE="install.wim"
else
    log "[ERROR] Unknown file type: $extension. Exiting.\n"
    exit 1
fi

log "[INFO] Available editions:\n"
AVAILABLE_IMAGES=$("$BIN_DIR/wimlib-imagex" info "$SELECTED_WIN_FILE" | grep -E '^Index:|^Name:')
if [ -z "$AVAILABLE_IMAGES" ]; then
    log "[ERROR] Failed to retrieve image indexes. The selected Windows file may be corrupted.\n"
    exit 1
fi
echo "$AVAILABLE_IMAGES\n"

log "[INFO] fixing GPT for 24h2 Windows\n\n"
for dev in a b c d e f; do
    "$BIN_DIR/gdisk" "/dev/block/sd$dev" <<< $'x\nj\n\nk\n\nw\nY\n'
    echo " "
done
log "[SUCCESS] GPT fix Done!\n"

# Backup critical partitions
log "[INFO] Backing up important partitions...\n"
for part in boot dtbo vendor_boot; do
    echo "Backing up $part.img..."
    "$BIN_DIR/busybox" dd if=/dev/block/platform/soc/1d84000.ufshc/by-name/$part$(getprop ro.boot.slot_suffix) of=$BACKUP_DIR/$part.img bs=8M 2>&1 | grep 'bytes'
done
for part in persist fsc fsg modemst1 modemst2; do
    echo "Backing up $part.img..."
    "$BIN_DIR/busybox" dd if=/dev/block/platform/soc/1d84000.ufshc/by-name/$part of=$BACKUP_DIR/$part.img bs=8M 2>&1 | grep 'bytes'
done
log "[SUCCESS] Backing up partitions Done!\n"

# Unmount and format partitions
log "[INFO] Unmounting and formatting partitions...\n"
umount -lf /dev/block/platform/soc/1d84000.ufshc/by-name/{esp,win} 2>/dev/null
"$BIN_DIR/mkfs.fat" -F32 -s1 /dev/block/platform/soc/1d84000.ufshc/by-name/esp -n ESPNABU
LD_PRELOAD=$BIN_DIR/libfuse-lite.so:$BIN_DIR/libntfs-3g.so $BIN_DIR/mkfs.ntfs -f /dev/block/platform/soc/1d84000.ufshc/by-name/win -L WINNABU

# Mount partitions
log "[INFO] Mounting partitions..."
mkdir -p "$WORK_DIR/win"
if ! LD_PRELOAD="$BIN_DIR/libfuse-lite.so:$BIN_DIR/libntfs-3g.so" \
    "$BIN_DIR/mount.ntfs" /dev/block/platform/soc/1d84000.ufshc/by-name/win "$WORK_DIR/win"; then
    log "[ERROR] Failed to mount NTFS partition at $WORK_DIR/win\n"
    exit 1
fi

log "[INFO] Copying Drivers to Win, please wait..."
copy_folder_with_progress "$WORK_DIR/installer" "$WORK_DIR/win/installer"

log "[INFO] Copying ToolBox to Win, please wait..."
copy_folder_with_progress "$WORK_DIR/ToolBox" "$WORK_DIR/win/ToolBox"

log "[INFO] Copying backuped images to Win, please wait..."
copy_folder_with_progress "$BACKUP_DIR" "$WORK_DIR/win/backup-images"

log "[INFO] Copying Windows file to Win, please wait..."
copy_file_with_progress "$SELECTED_WIN_FILE" "$WORK_DIR/win/installer/$DEST_FILE"

log "[INFO] Copying boot.img file to Windows partition..."
copy_file_with_progress "$BACKUP_DIR/boot.img" "$WORK_DIR/win/boot.img"

log "[INFO] flashing winpe image to the device..."
"$BIN_DIR/pv" -s "$("$BIN_DIR/busybox" stat -c%s "$WORK_DIR/pe.img")" "$WORK_DIR/pe.img" > /dev/block/platform/soc/1d84000.ufshc/by-name/esp

log "[INFO] flashing uefi image to the device..."
"$BIN_DIR/pv" -s "$("$BIN_DIR/busybox" stat -c%s "$WORK_DIR/uefi.img")" "$WORK_DIR/uefi.img" > /dev/block/platform/soc/1d84000.ufshc/by-name/boot$(getprop ro.boot.slot_suffix)

log "[INFO] installing WOA HELPER APP for dualboot to Windows..."
"$BIN_DIR/busybox" cp "$WORK_DIR/woahelper.apk" "$BIN_DIR/woahelper.apk"
pm install -t "$BIN_DIR/woahelper.apk"

log "[INFO] Cleaning up..."
cd
umount -lf /dev/block/platform/soc/1d84000.ufshc/by-name/{esp,win} 2>/dev/null
rm -rf "/tmp/arkt"
rm -rf "$WORK_DIR"
log "[SUCCESS] Cleanup complete, All Set!"

echo "*************************************************"
echo "  ArKT Magic No PC Wininstall Process Complete!  "
echo "*************************************************"